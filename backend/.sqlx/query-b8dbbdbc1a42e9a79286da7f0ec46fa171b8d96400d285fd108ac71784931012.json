{
  "db_name": "PostgreSQL",
  "query": "\n        WITH state_transitions AS (\n            -- For each edge, identify the state transitions it represents\n            -- and find the maximum time for each from->to state pattern\n            SELECT DISTINCT ON (from_state, to_state)\n                g1.edge_id,\n                g1.state_id as from_state,\n                g2.state_id as to_state,\n                g1.time\n            FROM geo_arg g1\n            INNER JOIN geo_arg g2 ON g1.edge_id = g2.edge_id\n            WHERE g1.time < g2.time  -- Ensure proper time ordering within edge\n            ORDER BY from_state, to_state, g1.time DESC  -- Get most ancient transition for each pattern\n        )\n        -- Get all geo_arg entries for the selected edges\n        SELECT\n            g.edge_id,\n            g.state_id,\n            g.time\n        FROM geo_arg g\n        INNER JOIN (\n            SELECT DISTINCT edge_id\n            FROM state_transitions\n            WHERE from_state = $1 OR to_state = $1\n        ) selected_edges ON g.edge_id = selected_edges.edge_id\n        ORDER BY g.edge_id, g.time\n        ",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "edge_id",
        "type_info": "Int4"
      },
      {
        "ordinal": 1,
        "name": "state_id",
        "type_info": "Int4"
      },
      {
        "ordinal": 2,
        "name": "time",
        "type_info": "Float8"
      }
    ],
    "parameters": {
      "Left": [
        "Int4"
      ]
    },
    "nullable": [
      false,
      false,
      false
    ]
  },
  "hash": "b8dbbdbc1a42e9a79286da7f0ec46fa171b8d96400d285fd108ac71784931012"
}
